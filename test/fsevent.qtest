#!/usr/bin/env qore
#
%new-style

%requires Util
%requires QUnit
%requires fsevent

#%include ./_some_module_to_test

%exec-class Main


const ITERATIONS = 100;
const THREADS = 10;


# let's try to find unique file name
our hash fnames;
synchronized sub get_tmp_fname() {
    my int tid = gettid();
    fnames{tid}++;
    return sprintf("tid%d_%d.txt", tid, fnames{tid});
}


class Watcher inherits public FSWatcher
{
    private {
        Main m_ut;
    }

    constructor(Main ut) : FSWatcher() {
        m_ut = ut;
    }

    nothing event(int id, string dir, string fname, int action, string oldFname) {
        string am = ACTION_MAP{action};
        string testname = fname + ": " + am;
        code c = sub() {return exists m_ut.files{fname}{am}; };
        m_ut.testAssertion(testname, c);
        delete m_ut.files{fname}{am};

        if (!m_ut.files{fname}.size()) {
            delete m_ut.files{fname};
        }
    }

} # class Watcher

public class Main inherits QUnit::Test {
    private {
        Dir m_dir();
        string m_subdir = sprintf("fsevent-unittest-pid_%d", getpid());
        Counter m_c();
    }

    public {
        hash files;
    }

    constructor() : Test("fsevent", "1.0") {
        addTestCase("Single Thread - SingleInstance", \singleInstance());
        addTestCase("Single Thread - MultiInstance", \multiInstance());
        addTestCase("Multi Threads - MultiInstance", \multipleThreads());

        # Return for compatibility with test harness that checks return value.
        set_return_value(main());
    }

    globalSetUp() {
        m_dir.chdir(Util::tmp_location());
        m_dir.mkdir(m_subdir);
        m_dir.chdir(m_subdir);
    }

    globalTearDown() {
        m_dir.chdir("..");
        m_dir.rmdir(m_subdir);
    }

    # This test is a little bit tricky. We just prepare set of expected
    # events and these are checked in the time of real event emitation.
    # These actions are removed then and we can assume that the test
    # is complete when there are no expected actions for given file name.
    private testOneFile() {
        # increase counter for each filename we are expecting
        m_c.inc();
        on_exit m_c.dec();

        string f1 = get_tmp_fname();
        string f2 = f1 + ".new";

        files{f1}."ADD" = True;
        files{f1}."MODIFIED" = True;
        files{f2}."MOVED" = True;
        files{f1}."MOVED" = True;
        files{f1}."DELETE" = True;

        File f = m_dir.openFile(f1, O_CREAT | O_TRUNC | O_WRONLY, 0644);
        f.write('lorem ipsum');
        f.close();

        rename(m_dir.path() + "/" + f1, m_dir.path() + "/" + f2);
        rename(m_dir.path() + "/" + f2, m_dir.path() + "/" + f1);
        m_dir.removeFile(f1);
    }

    singleInstance() {
        Watcher w(self);
        w.addPath(m_dir.path(), True);

        testOneFile();

        m_c.waitForZero();
        w.removePath(m_dir.path());

        # lets' wait for pending events
        sleep(1);
    }

    private testFilesSet() {
        for (int i = 0; i < ITERATIONS; i++) {
            testOneFile();
        }
    }

    multiInstance() {
        Watcher w(self);
        w.addPath(m_dir.path(), True);

        testFilesSet();

        m_c.waitForZero();
        w.removePath(m_dir.path());

        # lets' wait for pending events
        sleep(1);
    }

    multipleThreads() {
        m_c.inc();
        Watcher w(self);
        w.addPath(m_dir.path(), True);

        for (int i = 0; i < THREADS; i++) {
            background testFilesSet();
        }

        m_c.dec();
        m_c.waitForZero();
        w.removePath(m_dir.path());

        # lets' wait for pending events
        sleep(1);
    }
}
